// Generated by CoffeeScript 1.9.0
var RRule, moment;

moment = require('moment-timezone');

RRule = require('rrule').RRule;

module.exports = function(Event) {
  var VAlarm, VCalendar, VEvent, _ref;
  _ref = require('./index'), VCalendar = _ref.VCalendar, VEvent = _ref.VEvent, VAlarm = _ref.VAlarm;
  Event.prototype.toIcal = function(timezone) {
    var allDay, created, e, event, lastModification, mappedAttendees, rrule, stampDate, _ref1, _ref2;
    if (timezone == null) {
      timezone = 'UTC';
    }
    allDay = this.start.length === 10;
    if (this.rrule) {
      if (this.timezone != null) {
        timezone = this.timezone;
      } else if (!allDay) {
        console.log("Recurring events need timezone.");
      }
    }
    timezone = this.timezone || timezone;
    rrule = this.rrule != null ? RRule.parseString(this.rrule) : null;
    mappedAttendees = (_ref1 = this.attendees) != null ? _ref1.map(function(attendee) {
      return {
        email: attendee.email,
        status: attendee.status
      };
    }) : void 0;
    created = this.created || null;
    lastModification = this.lastModification || null;
    stampDate = this.lastModification || moment().tz('UTC');
    stampDate = moment.tz(stampDate, 'UTC').toDate();
    try {
      event = new VEvent({
        stampDate: stampDate,
        startDate: moment.tz(this.start, timezone),
        endDate: moment.tz(this.end, timezone),
        summary: this.description,
        location: this.place,
        uid: this.id,
        description: this.details,
        allDay: allDay,
        rrule: rrule,
        attendees: mappedAttendees,
        timezone: timezone,
        created: created,
        lastModification: lastModification,
        mozLastack: this.mozLastack
      });
    } catch (_error) {
      e = _error;
      console.log('Can\'t parse event mandatory fields.');
      console.log(e);
      return void 0;
    }
    if ((_ref2 = this.alarms) != null) {
      _ref2.forEach((function(_this) {
        return function(alarm) {
          var _ref3, _ref4;
          if ((_ref3 = alarm.action) === VAlarm.DISPLAY_ACTION || _ref3 === 'BOTH') {
            event.add(new VAlarm({
              trigger: alarm.trigg,
              action: VAlarm.DISPLAY_ACTION,
              description: _this.description
            }));
          }
          if (((_ref4 = alarm.action) === VAlarm.EMAIL_ACTION || _ref4 === 'BOTH') && (_this.getAlarmAttendeesEmail != null)) {
            mappedAttendees = _this.getAlarmAttendeesEmail().map(function(email) {
              return {
                email: email,
                status: 'ACCEPTED'
              };
            });
            return event.add(new VAlarm({
              trigger: alarm.trigg,
              action: VAlarm.EMAIL_ACTION,
              summary: _this.description,
              description: _this.details || '',
              attendees: mappedAttendees
            }));
          }
        };
      })(this));
    }
    return event;
  };
  Event.fromIcal = function(vevent, defaultCalendar) {
    var alarms, defaultCozyStatus, end, event, model, now, stampDate, start, timezone, _ref1;
    if (defaultCalendar == null) {
      defaultCalendar = 'my calendar';
    }
    event = new Event();
    model = vevent.model;
    now = moment().tz('UTC').toISOString();
    timezone = model.timezone || 'UTC';
    if (model.uid != null) {
      event.id = model.uid;
    }
    event.description = model.summary || '';
    event.details = model.description || '';
    event.place = model.location;
    event.rrule = new RRule(model.rrule).toString();
    defaultCozyStatus = 'INVITATION-NOT-SENT';
    event.attendees = (_ref1 = model.attendees) != null ? _ref1.map(function(attendee, index) {
      var contactid, email, id, status, _ref2;
      status = ((_ref2 = attendee.details) != null ? _ref2.status : void 0) || defaultCozyStatus;
      if (status === 'NEEDS-ACTION') {
        status = defaultCozyStatus;
      }
      email = attendee.email;
      id = index + 1;
      contactid = null;
      return {
        id: id,
        email: email,
        contactid: contactid,
        status: status
      };
    }) : void 0;
    if (model.created != null) {
      event.created = model.created;
    }
    stampDate = moment.tz(model.stampDate, 'UTC').toISOString();
    event.lastModification = model.lastModification || stampDate || now;
    event.mozLastack = model.mozLastack;
    if (model.allDay) {
      event.start = moment.tz(model.startDate, 'UTC').format(Event.dateFormat);
      event.end = moment.tz(model.endDate, 'UTC').format(Event.dateFormat);
    } else {
      if (timezone !== 'UTC') {
        start = moment.tz(model.startDate, timezone);
        end = moment.tz(model.endDate, timezone);
      } else {
        start = moment.tz(model.startDate, 'UTC');
        end = moment.tz(model.endDate, 'UTC');
      }
      if (model.rrule != null) {
        event.timezone = timezone;
        event.start = start.format(Event.ambiguousDTFormat);
        event.end = end.format(Event.ambiguousDTFormat);
      } else {
        event.start = start.toISOString();
        event.end = end.toISOString();
      }
    }
    alarms = [];
    vevent.subComponents.forEach(function(component) {
      var action, alarmModel, trigg;
      if (component.name === !'VALARM') {
        return;
      }
      alarmModel = component.model;
      trigg = alarmModel.trigger;
      action = alarmModel.action;
      if (trigg && trigg.match(Event.alarmTriggRegex)) {
        return alarms.push({
          trigg: trigg,
          action: action
        });
      }
    });
    if (alarms) {
      event.alarms = alarms;
    }
    event.tags = [defaultCalendar];
    return event;
  };
  return Event.extractEvents = function(component, defaultCalendar) {
    var events;
    if (defaultCalendar == null) {
      defaultCalendar = 'my calendar';
    }
    events = [];
    component.walk(function(component) {
      if (component.name === 'VEVENT') {
        return events.push(Event.fromIcal(component, defaultCalendar));
      }
    });
    return events;
  };
};
